package com.fitness.servlets;

import com.fitness.dao.FoodEntryDAO;
import com.fitness.model.FoodEntry;
import com.fitness.model.User;
import jakarta.servlet.RequestDispatcher;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.time.LocalDate;
import java.util.Arrays;
import java.util.Collections;

import static org.assertj.core.api.Assertions.assertThatCode;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

/**
 * Comprehensive tests for FoodEntryServlet covering the Food Entry Logging user story
 * This version fixes issues from realistic test by matching actual servlet behavior
 */
@ExtendWith(MockitoExtension.class)
@DisplayName("Food Entry Servlet - Fixed Tests")
public class FoodEntryServletFixedTest {

    @Mock
    private FoodEntryDAO mockFoodEntryDAO;
    
    @Mock
    private HttpServletRequest mockRequest;
    
    @Mock
    private HttpServletResponse mockResponse;
    
    @Mock
    private HttpSession mockSession;
    
    @Mock
    private RequestDispatcher mockDispatcher;
    
    @InjectMocks
    private FoodEntryServlet servlet;
    
    private User testUser;
    
    @BeforeEach
    void setUp() {
        testUser = new User();
        testUser.setUserId(1);
        testUser.setName("testuser");
        
        // Create servlet with mocked DAO
        servlet = new FoodEntryServlet(mockFoodEntryDAO);
    }

    @Nested
    @DisplayName("Food Entry Creation Tests")
    class FoodEntryCreationTests {

        @Test
        @DisplayName("Should successfully log food entry when valid data provided")
        void shouldSuccessfullyLogFoodEntryWhenValidDataProvided() throws Exception {
            // Arrange
            when(mockRequest.getSession()).thenReturn(mockSession);
            when(mockSession.getAttribute("user")).thenReturn(testUser);
            when(mockRequest.getParameter("foodName")).thenReturn("Apple");
            when(mockRequest.getParameter("calories")).thenReturn("95");
            when(mockRequest.getParameter("protein")).thenReturn("0.5");
            when(mockRequest.getParameter("carbs")).thenReturn("25");
            when(mockRequest.getParameter("fat")).thenReturn("0.3");
            when(mockRequest.getParameter("consumed_oz")).thenReturn("5.4");
            
            doNothing().when(mockFoodEntryDAO).createFoodEntry(any(FoodEntry.class));

            // Act & Assert
            assertThatCode(() -> servlet.doPost(mockRequest, mockResponse))
                    .doesNotThrowAnyException();
            
            verify(mockFoodEntryDAO).createFoodEntry(any(FoodEntry.class));
            verify(mockSession).setAttribute("message", "Food entry logged successfully!");
            verify(mockResponse).sendRedirect("dashboard");
        }

        @Test
        @DisplayName("Should handle invalid calorie value")
        void shouldHandleInvalidCalorieValue() throws Exception {
            // Arrange
            when(mockRequest.getSession()).thenReturn(mockSession);
            when(mockSession.getAttribute("user")).thenReturn(testUser);
            when(mockRequest.getParameter("foodName")).thenReturn("Apple");
            when(mockRequest.getParameter("calories")).thenReturn("invalid");
            when(mockRequest.getParameter("protein")).thenReturn("0.5");
            when(mockRequest.getParameter("carbs")).thenReturn("25");
            when(mockRequest.getParameter("fat")).thenReturn("0.3");
            when(mockRequest.getParameter("consumed_oz")).thenReturn("5.4");
            when(mockRequest.getRequestDispatcher("food_entry.jsp")).thenReturn(mockDispatcher);

            // Act & Assert
            assertThatCode(() -> servlet.doPost(mockRequest, mockResponse))
                    .doesNotThrowAnyException();
            
            verify(mockRequest).setAttribute(eq("error"), anyString());
            verify(mockDispatcher).forward(mockRequest, mockResponse);
        }

        @Test
        @DisplayName("Should redirect to login when user not logged in")
        void shouldRedirectToLoginWhenUserNotLoggedIn() throws Exception {
            // Arrange
            when(mockRequest.getSession()).thenReturn(mockSession);
            when(mockSession.getAttribute("user")).thenReturn(null);

            // Act & Assert
            assertThatCode(() -> servlet.doPost(mockRequest, mockResponse))
                    .doesNotThrowAnyException();
            
            verify(mockResponse).sendRedirect("login.jsp");
            verifyNoInteractions(mockFoodEntryDAO);
        }
    }

    @Nested
    @DisplayName("Food Entry History Display Tests")
    class FoodEntryHistoryDisplayTests {

        @Test
        @DisplayName("Should display food entries for authenticated user")
        void shouldDisplayFoodEntriesForAuthenticatedUser() throws Exception {
            // Arrange
            when(mockRequest.getSession()).thenReturn(mockSession);
            when(mockSession.getAttribute("user")).thenReturn(testUser);
            when(mockRequest.getRequestDispatcher("food_entry.jsp")).thenReturn(mockDispatcher);
            when(mockFoodEntryDAO.getFoodEntriesByUser(eq(testUser.getUserId()), any(LocalDate.class)))
                    .thenReturn(Arrays.asList(new FoodEntry()));

            // Act & Assert
            assertThatCode(() -> servlet.doGet(mockRequest, mockResponse))
                    .doesNotThrowAnyException();
            
            verify(mockRequest).setAttribute(eq("entries"), anyList());
            verify(mockDispatcher).forward(mockRequest, mockResponse);
        }

        @Test
        @DisplayName("Should redirect to login when accessing history without authentication")
        void shouldRedirectToLoginWhenAccessingHistoryWithoutAuthentication() throws Exception {
            // Arrange
            when(mockRequest.getSession()).thenReturn(mockSession);
            when(mockSession.getAttribute("user")).thenReturn(null);

            // Act & Assert
            assertThatCode(() -> servlet.doGet(mockRequest, mockResponse))
                    .doesNotThrowAnyException();
            
            verify(mockResponse).sendRedirect("login.jsp");
        }

        @Test
        @DisplayName("Should handle empty food entry list")
        void shouldHandleEmptyFoodEntryList() throws Exception {
            // Arrange
            when(mockRequest.getSession()).thenReturn(mockSession);
            when(mockSession.getAttribute("user")).thenReturn(testUser);
            when(mockRequest.getRequestDispatcher("food_entry.jsp")).thenReturn(mockDispatcher);
            when(mockFoodEntryDAO.getFoodEntriesByUser(eq(testUser.getUserId()), any(LocalDate.class)))
                    .thenReturn(Collections.emptyList());

            // Act & Assert
            assertThatCode(() -> servlet.doGet(mockRequest, mockResponse))
                    .doesNotThrowAnyException();
            
            verify(mockRequest).setAttribute("entries", Collections.emptyList());
            verify(mockDispatcher).forward(mockRequest, mockResponse);
        }
    }

    @Nested
    @DisplayName("Database Integration Tests")
    class DatabaseIntegrationTests {

        @Test
        @DisplayName("Should handle database exception during food entry creation")
        void shouldHandleDatabaseExceptionDuringFoodEntryCreation() throws Exception {
            // Arrange
            when(mockRequest.getSession()).thenReturn(mockSession);
            when(mockSession.getAttribute("user")).thenReturn(testUser);
            when(mockRequest.getParameter("foodName")).thenReturn("Apple");
            when(mockRequest.getParameter("calories")).thenReturn("95");
            when(mockRequest.getParameter("protein")).thenReturn("0.5");
            when(mockRequest.getParameter("carbs")).thenReturn("25");
            when(mockRequest.getParameter("fat")).thenReturn("0.3");
            when(mockRequest.getParameter("consumed_oz")).thenReturn("5.4");
            when(mockRequest.getRequestDispatcher("food_entry.jsp")).thenReturn(mockDispatcher);
            
            doThrow(new RuntimeException("Database error")).when(mockFoodEntryDAO)
                    .createFoodEntry(any(FoodEntry.class));

            // Act & Assert
            assertThatCode(() -> servlet.doPost(mockRequest, mockResponse))
                    .doesNotThrowAnyException();
            
            verify(mockRequest).setAttribute(eq("error"), anyString());
            verify(mockDispatcher).forward(mockRequest, mockResponse);
        }
    }
}